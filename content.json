{"meta":{"title":"笔记","subtitle":null,"description":null,"author":"闲淡酱","url":"https://copy.moe","root":"/"},"pages":[{"title":"关于","date":"2018-09-16T11:54:59.000Z","updated":"2019-08-25T07:29:42.041Z","comments":true,"path":"about/index.html","permalink":"https://copy.moe/about/index.html","excerpt":"","text":"@card{ 用来记录些笔记，顺便玩玩Hexo，万一以后没钱买服务器了呢。托管于GitHub。 }"},{"title":"分类","date":"2018-09-15T08:25:41.000Z","updated":"2019-08-25T07:09:40.467Z","comments":false,"path":"categories/index.html","permalink":"https://copy.moe/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-15T08:25:33.000Z","updated":"2019-08-25T07:09:45.053Z","comments":false,"path":"tags/index.html","permalink":"https://copy.moe/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git基本使用","slug":"git","date":"2019-04-04T15:01:50.000Z","updated":"2019-07-25T08:51:29.505Z","comments":true,"path":"2019/04/04/git/","link":"","permalink":"https://copy.moe/2019/04/04/git/","excerpt":"","text":"创建仓库初始化当前目录1git init 初始化并新建目录1git init demo 克隆项目1git clone https://xxx.com/xxx.git 克隆项目到指定目录1git clone https://xxx.com/xxx.git demo 基本用法查看仓库状态1git status 将修改添加至暂存区12git add . // 添加所有git add xxx.txt // 添加指定文件 提交版本1git commit -m &quot;描述&quot; 查看版本记录12345git loggit log -p // 查看具体记录git log --oneline // 每个记录一行显示git log --all //显示全部git log --all --graph // 图示全部历史记录 穿越到指定的历史节点1git checkout xxxxxxx 回到之前的节点1git checkout - tag 标签12345git tag //列出所有标签git tag -a 标签名 -m &quot;描述&quot; // commit后添加taggit tag -a 标签名 -m &quot;描述&quot; xxxxxxx // 指定节点添加taggit show 标签名 // 查看某个标签的详细信息git checkout 标签名 // 回溯至标签所在的提交 branch 分支123git branch xxx // 创建分支git checkout xxx // 切换到分支git checkout -b xxx // 创建并切换分支 合并分支1git merge xxx // 合并到当前所在的分支 远程仓库1234git remote add 远程名称 远程地址 //添加远程仓库git remote //列出所有远程仓库git remote -v //列出详细信息git push -u 远程名 分支名 //上传代码 多人远程合作1git pull //获取远程更新 同时修改代码遇到冲突，先pull一次，解决冲突，再提交上传。 1git pull 等同于 git fetch &amp;&amp; git merge","categories":[{"name":"代码","slug":"代码","permalink":"https://copy.moe/categories/代码/"}],"tags":[{"name":"git","slug":"git","permalink":"https://copy.moe/tags/git/"}]},{"title":"Less预处理器","slug":"less","date":"2019-04-02T14:26:13.000Z","updated":"2019-04-04T14:59:55.350Z","comments":true,"path":"2019/04/02/less/","link":"","permalink":"https://copy.moe/2019/04/02/less/","excerpt":"","text":"在命令行下使用你可以在终端调用 LESS 解析器: 1$ lessc styles.less 上面的命令会将编译后的 CSS 传递给 stdout, 你可以将它保存到一个文件中: 1$ lessc styles.less &gt; styles.css 如何你想将编译后的 CSS 压缩掉，那么加一个 -x 参数就可以了。 LESS 语法LESS 做为 CSS 的一种形式的扩展，它并没有阉割 CSS 的功能，而是在现有的 CSS 语法上，添加了很多额外的功能，所以学习 LESS 是一件轻而易举的事情，果断学习之！ 变量很容易理解: 1234@nice-blue: #5B83AD;@light-blue: @nice-blue + #111;#header &#123; color: @light-blue; &#125; 输出: 1#header &#123; color: #6c94be; &#125; 甚至可以用变量名定义为变量: 123@fnord: &quot;I am fnord.&quot;;@var: &apos;fnord&apos;;content: @@var; 解析后: 1content: &quot;I am fnord.&quot;; 请注意 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次. 混合在 LESS 中我们可以定义一些通用的属性集为一个class，然后在另一个class中去调用这些属性. 下面有这样一个class: 1234.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125; 那如果我们现在需要在其他class中引入那些通用的属性集，那么我们只需要在任何class中像下面这样调用就可以了: 12345678#menu a &#123; color: #111; .bordered;&#125;.post a &#123; color: red; .bordered;&#125; .bordered class里面的属性样式都会在 #menu a 和 .post a中体现出来: 12345678910#menu a &#123; color: #111; border-top: dotted 1px black; border-bottom: solid 2px black;&#125;.post a &#123; color: red; border-top: dotted 1px black; border-bottom: solid 2px black;&#125; 任何 CSS class, id 或者 元素 属性集都可以以同样的方式引入. 带参数混合在 LESS 中，你还可以像函数一样定义一个带参数的属性集合: 12345.border-radius (@radius) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125; 然后在其他class中像这样调用它: 123456#header &#123; .border-radius(4px);&#125;.button &#123; .border-radius(6px); &#125; 我们还可以像这样给参数设置默认值: 12345.border-radius (@radius: 5px) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125; 所以现在如果我们像这样调用它的话: 123#header &#123; .border-radius; &#125; radius的值就会是5px. 你也可以定义不带参数属性集合,如果你想隐藏这个属性集合，不让它暴露到CSS中去，但是你还想在其他的属性集合中引用，你会发现这个方法非常的好用: 12345678.wrap () &#123; text-wrap: wrap; white-space: pre-wrap; white-space: -moz-pre-wrap; word-wrap: break-word;&#125;pre &#123; .wrap &#125; 输出: 123456pre &#123; text-wrap: wrap; white-space: pre-wrap; white-space: -moz-pre-wrap; word-wrap: break-word;&#125; @arguments 变量@arguments包含了所有传递进来的参数. 如果你不想单独处理每一个参数的话就可以像这样写: 123456.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) &#123; box-shadow: @arguments; -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments;&#125;.box-shadow(2px, 5px); 将会输出: 123box-shadow: 2px 5px 1px #000;-moz-box-shadow: 2px 5px 1px #000;-webkit-box-shadow: 2px 5px 1px #000; 模式匹配和导引表达式有些情况下，我们想根据传入的参数来改变混合的默认呈现，比如下面这个例子： 12345.mixin (@s, @color) &#123; ... &#125;.class &#123; .mixin(@switch, #888);&#125; 如果想让.mixin根据不同的@switch值而表现各异，如下这般设置： 123456789.mixin (dark, @color) &#123; color: darken(@color, 10%);&#125;.mixin (light, @color) &#123; color: lighten(@color, 10%);&#125;.mixin (@_, @color) &#123; display: block;&#125; 现在，如果运行: 12345@switch: light;.class &#123; .mixin(@switch, #888);&#125; 就会得到下列CSS: 1234.class &#123; color: #a2a2a2; display: block;&#125; 如上，.mixin就会得到传入颜色的浅色。如果@switch设为dark，就会得到深色。 具体实现如下： 第一个混合定义并未被匹配，因为它只接受dark做为首参 第二个混合定义被成功匹配，因为它只接受light 第三个混合定义被成功匹配，因为它接受任意值 只有被匹配的混合才会被使用。变量可以匹配任意的传入值，而变量以外的固定值就仅仅匹配与其相等的传入值。 我们也可以匹配多个参数： 123456.mixin (@a) &#123; color: @a;&#125;.mixin (@a, @b) &#123; color: fade(@a, @b);&#125; Now if we call .mixin with a single argument, we will get the output of the first definition, but if we call it with two arguments, we will get the second definition, namely @a faded to @b. 引导当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。 为了尽可能地保留CSS的可声明性，LESS通过导引混合而非if/else语句来实现条件判断，因为前者已在@media query特性中被定义。 以此例做为开始： 123456789.mixin (@a) when (lightness(@a) &gt;= 50%) &#123; background-color: black;&#125;.mixin (@a) when (lightness(@a) &lt; 50%) &#123; background-color: white;&#125;.mixin (@a) &#123; color: @a;&#125; when关键字用以定义一个导引序列(此例只有一个导引)。接下来我们运行下列代码： 12.class1 &#123; .mixin(#ddd) &#125;.class2 &#123; .mixin(#555) &#125; 就会得到： 12345678.class1 &#123; background-color: black; color: #ddd;&#125;.class2 &#123; background-color: white; color: #555;&#125; 导引中可用的全部比较运算有： &gt; &gt;= = =&lt; &lt;。此外，关键字true只表示布尔真值，下面两个混合是相同的： 12.truth (@a) when (@a) &#123; ... &#125;.truth (@a) when (@a = true) &#123; ... &#125; 除去关键字true以外的值都被视示布尔假： 123.class &#123; .truth(40); // Will not match any of the above definitions.&#125; 导引序列使用逗号‘,’—分割，当且仅当所有条件都符合时，才会被视为匹配成功。 1.mixin (@a) when (@a &gt; 10), (@a &lt; -10) &#123; ... &#125; 导引可以无参数，也可以对参数进行比较运算： 1234567@media: mobile;.mixin (@a) when (@media = mobile) &#123; ... &#125;.mixin (@a) when (@media = desktop) &#123; ... &#125;.max (@a, @b) when (@a &gt; @b) &#123; width: @a &#125;.max (@a, @b) when (@a &lt; @b) &#123; width: @b &#125; 最后，如果想基于值的类型进行匹配，我们就可以使用is*函式： 12.mixin (@a, @b: 0) when (isnumber(@b)) &#123; ... &#125;.mixin (@a, @b: black) when (iscolor(@b)) &#123; ... &#125; 下面就是常见的检测函式： iscolor isnumber isstring iskeyword isurl 如果你想判断一个值是纯数字，还是某个单位量，可以使用下列函式： ispixel ispercentage isem 最后再补充一点，在导引序列中可以使用and关键字实现与条件： 1.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) &#123; ... &#125; 使用not关键字实现或条件 1.mixin (@b) when not (@b &gt; 0) &#123; ... &#125; 嵌套规则LESS 可以让我们以嵌套的方式编写层叠样式. 让我们先看下下面这段 CSS: 12345678910#header &#123; color: black; &#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px; &#125;#header .logo:hover &#123; text-decoration: none;&#125; 在 LESS 中, 我们就可以这样写: 1234567891011#header &#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &amp;:hover &#123; text-decoration: none &#125; &#125;&#125; 或者这样写: 123456#header &#123; color: black; .navigation &#123; font-size: 12px &#125; .logo &#123; width: 300px; &amp;:hover &#123; text-decoration: none &#125; &#125;&#125; 代码更简洁了，而且感觉跟DOM结构格式有点像. 注意 &amp; 符号的使用—如果你想写串联选择器，而不是写后代选择器，就可以用到&amp;了. 这点对伪类尤其有用如 :hover 和 :focus. 例如: 12345678.bordered &#123; &amp;.float &#123; float: left; &#125; .top &#123; margin: 5px; &#125;&#125; 会输出 123456.bordered.float &#123; float: left; &#125;.bordered .top &#123; margin: 5px;&#125; 运算任何数字、颜色或者变量都可以参与运算. 来看一组例子: 1234567@base: 5%;@filler: @base * 2;@other: @base + @filler;color: #888 / 4;background-color: @base-color + #111;height: 100% / 2 + @filler; LESS 的运算已经超出了我们的期望，它能够分辨出颜色和单位。如果像下面这样单位运算的话: 1@var: 1px + 5; LESS 会输出 6px. 括号也同样允许使用: 1width: (@var + 5) * 2; 并且可以在复合属性中进行运算: 1border: (@width * 2) solid black; Color 函数LESS 提供了一系列的颜色运算函数. 颜色会先被转化成 HSL 色彩空间, 然后在通道级别操作: 1234567891011121314lighten(@color, 10%); // return a color which is 10% *lighter* than @colordarken(@color, 10%); // return a color which is 10% *darker* than @colorsaturate(@color, 10%); // return a color 10% *more* saturated than @colordesaturate(@color, 10%); // return a color 10% *less* saturated than @colorfadein(@color, 10%); // return a color 10% *less* transparent than @colorfadeout(@color, 10%); // return a color 10% *more* transparent than @colorfade(@color, 50%); // return @color with 50% transparencyspin(@color, 10); // return a color with a 10 degree larger in hue than @colorspin(@color, -10); // return a color with a 10 degree smaller hue than @colormix(@color1, @color2); // return a mix of @color1 and @color2 使用起来相当简单: 123456@base: #f04615;.class &#123; color: saturate(@base, 5%); background-color: lighten(spin(@base, 8), 25%);&#125; 你还可以提取颜色信息: 123hue(@color); // returns the `hue` channel of @colorsaturation(@color); // returns the `saturation` channel of @colorlightness(@color); // returns the &apos;lightness&apos; channel of @color 如果你想在一种颜色的通道上创建另一种颜色，这些函数就显得那么的好用，例如: 1@new: hsl(hue(@old), 45%, 90%); @new 将会保持 @old的 色调, 但是具有不同的饱和度和亮度. Math 函数LESS提供了一组方便的数学函数，你可以使用它们处理一些数字类型的值: 123round(1.67); // returns `2`ceil(2.4); // returns `3`floor(2.6); // returns `2` 如果你想将一个值转化为百分比，你可以使用percentage 函数: 1percentage(0.5); // returns `50%` 命名空间有时候，你可能为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 你可以像下面这样在#bundle中定义一些属性集之后可以重复使用: 12345678910#bundle &#123; .button () &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125; 你只需要在 #header a中像这样引入 .button: 1234#header a &#123; color: orange; #bundle &gt; .button;&#125; 作用域LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止. 123456789101112@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125;#footer &#123; color: @var; // red &#125; 注释CSS 形式的注释在 LESS 中是依然保留的: 12/* Hello, I&apos;m a CSS-style comment */.class &#123; color: black &#125; LESS 同样也支持双斜线的注释, 但是编译成 CSS 的时候自动过滤掉: 12// Hi, I&apos;m a silent comment, I won&apos;t show up in your CSS.class &#123; color: white &#125; Importing你可以在main文件中通过下面的形势引入 .less 文件, .less 后缀可带可不带: 12@import &quot;lib.less&quot;;@import &quot;lib&quot;; 如果你想导入一个CSS文件而且不想LESS对它进行处理，只需要使用.css后缀就可以: 1@import &quot;lib.css&quot;; 这样LESS就会跳过它不去处理它. 字符串插值变量可以用类似ruby和php的方式嵌入到字符串中，像@{name}这样的结构: 12@base-url: &quot;http://assets.fnord.com&quot;;background-image: url(&quot;@&#123;base-url&#125;/images/bg.png&quot;); 避免编译有时候我们需要输出一些不正确的CSS语法或者使用一些 LESS不认识的专有语法. 要输出这样的值我们可以在字符串前加上一个 ~, 例如: 123.class &#123; filter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;&#125; 我们可以将要避免编译的值用 “”包含起来，输出结果为: 123.class &#123; filter: ms:alwaysHasItsOwnSyntax.For.Stuff();&#125; JavaScript 表达式JavaScript 表达式也可以在.less 文件中使用. 可以通过反引号的方式使用: 1@var: `&quot;hello&quot;.toUpperCase() + &apos;!&apos;`; 输出: 1@var: &quot;HELLO!&quot;; 注意你也可以同时使用字符串插值和避免编译: 12@str: &quot;hello&quot;;@var: ~`&quot;@&#123;str&#125;&quot;.toUpperCase() + &apos;!&apos;`; 输出: 1@var: HELLO!; 它也可以访问JavaScript环境: 1@height: `document.body.clientHeight`; 如果你想将一个JavaScript字符串解析成16进制的颜色值, 你可以使用 color 函数: 12@color: color(`window.colors.baseColor`);@darkcolor: darken(@color, 10%);","categories":[{"name":"代码","slug":"代码","permalink":"https://copy.moe/categories/代码/"}],"tags":[{"name":"less","slug":"less","permalink":"https://copy.moe/tags/less/"}]},{"title":"Vue.js使用axios","slug":"vue-axios","date":"2019-03-30T10:52:51.000Z","updated":"2019-07-11T09:26:03.142Z","comments":true,"path":"2019/03/30/vue-axios/","link":"","permalink":"https://copy.moe/2019/03/30/vue-axios/","excerpt":"","text":"在使用Vue开发项目的时候，从API请求数据是必不可少的。为此可以使用Vue官方推荐的axios来实现。 安装切换到Vue项目目录下，使用npm来安装插件。 1npm install --save axios vue-axios 打开main.js，注册组件 1234import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios, axios) 使用方法1234567891011Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 示例通过使用GitHub的API接口，来实现一个简单的用户搜索功能。当用户输入用户名后进行提交，在页面不刷新的前提下，异步请求API更新页面内容。 推荐使用vscode来开发，安装Veutr插件，提高开发效率。 新建一个component 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class=&quot;github&quot;&gt; &lt;form @submit.prevent=&quot;find()&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt; &lt;button type=&quot;submit&quot;&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;div class=&quot;user-info&quot; v-if=&quot;content&quot;&gt; &lt;img :src=&quot;content.avatar_url&quot; alt=&quot;avatar&quot; class=&quot;avatar&quot;&gt; &lt;p&gt;&#123;&#123; content.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; content.location &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; content.bio &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;github&quot;, data: function() &#123; return &#123; username: &quot;&quot;, content: &quot;&quot; &#125;; &#125;, methods: &#123; find: function() &#123; if (this.username != &quot;&quot;) &#123; this.axios .get(&quot;https://api.github.com/users/&quot; + this.username) .then(response =&gt; &#123; this.content = response.data; &#125;); &#125; else &#123; return false; &#125; &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;img.avatar &#123; width: 5em; height: 5em; border-radius: 50%;&#125;&lt;/style&gt;","categories":[{"name":"代码","slug":"代码","permalink":"https://copy.moe/categories/代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://copy.moe/tags/JavaScript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://copy.moe/tags/vue-js/"},{"name":"axios","slug":"axios","permalink":"https://copy.moe/tags/axios/"}]},{"title":"Vue CLI部署","slug":"vue-cli","date":"2019-03-30T10:45:28.000Z","updated":"2019-07-11T09:23:14.137Z","comments":true,"path":"2019/03/30/vue-cli/","link":"","permalink":"https://copy.moe/2019/03/30/vue-cli/","excerpt":"","text":"安装需要先安装好Node.js环境，此处省略。 切换到项目目录，全局安装Vue CLI 1npm install -g vue-cli 创建应用。不需要对Webpack有太多的了解，这一切Vue CLI都会帮我们完成。app是自定义的项目名称。 1vue init webpack app 首先会询问项目名，描述，作者三项，直接回车即可 接着有一个 vue build 选项，直接回车即可 然后会问要不要安装 vue-router，开发单页应用基本离不开路由，推荐选择安装 最后是语法检查，单元测试，项目测试三项直接输入 n 部署完成后，根据提示把命令敲一遍，然后即可通过localhost:8080访问你的应用。 12cd appnpm run dev","categories":[{"name":"代码","slug":"代码","permalink":"https://copy.moe/categories/代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://copy.moe/tags/JavaScript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://copy.moe/tags/vue-js/"}]},{"title":"在CentOS 7上添加Swap交换空间","slug":"centos-swap","date":"2018-10-27T02:48:36.000Z","updated":"2019-04-08T15:55:48.127Z","comments":true,"path":"2018/10/27/centos-swap/","link":"","permalink":"https://copy.moe/2018/10/27/centos-swap/","excerpt":"","text":"原文出处：https://blog.csdn.net/zstack_org/article/details/53258588 前言如何让服务器响应更快？如何避免应用出现内存不足的错误？最简单的方法就是增加交换空间。Swap是存储盘上的一块自留地，操作系统可以在这里暂存一些内存里放不下的东西。 这从某种程度上相当于增加了服务器的可用内存。虽然从swap读写比内存慢，但总比没有好，算是内存不够时的安全网。 如果没有swap，则服务器一旦内存不足，就会开始终止应用以释放内存，甚至会崩溃，这会让你丢失一些还没来得及保存的数据，或者造成当机。有些应用明确要求系统配置swap以确保数据访问的可靠性。 本文介绍如何在CentOS 7服务器上创建并启用swap文件。 注：swap通常在传统机械硬盘上表现更好，在SSD上使用swap可能会造成问题，尤其是硬件老化之后。所以，对于DigitalOcean以及其他使用基于SSD的云主机服务的用户，我们不推荐启用swap。这甚至会影响到跟你的虚拟机共用宿主机的其他用户。 对于DigitalOcean用户，提升性能的最佳方法就是更新Droplet。通常来说，升级后的主机表现都会有所提升，并且更不容易受到硬件问题的影响。 准备工作首先，你需要一台CentOS 7服务器，配置过具备sudo权限的非root用户（配置过程可参考这个教程的第一到第四步骤）。 准备就绪后，以该用户名SSH到你的CentOS服务器上，准备安装swap文件。 检查系统的Swap信息首先我们需要检查系统的存储，看看是否已经配置过swap。一个系统可以设置多个swap文件或分区，不过一般来说一个就够了。 使用swapon命令可以检查系统是否已经配置过swap，这是一个通用的swap工具。使用-s标签可列出当前存储设备上的swap使用情况： 1swapon -s 如果该命令没有返回出结果，则代表该系统尚未配置过swap。 或者，我们也可以使用free工具来查看系统的整体内存使用情况，这里可以看到内存和swap的使用状态（显示单位为MB）： 12345free -m total used free shared buffers cachedMem: 3953 315 3637 8 11 107-/+ buffers/cache: 196 3756Swap: 0 0 4095 这里可以看到我们这个系统的total swap空间为0，即没有配置过swap。这与我们在swapon里看到的结果相符合。 检查可用的存储空间通常，我们建立一个单独的分区作为swap。然而有时候由于硬件或软件的限制，新建分区的方式无法实现，这种情况下就可以建立一个swap文件来实现同样的功能。 开始之前，先检查一下磁盘的可用空间。输入如下指令： 123456789df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 59G 1.5G 55G 3% /devtmpfs 2.0G 0 2.0G 0% /devtmpfs 2.0G 0 2.0G 0% /dev/shmtmpfs 2.0G 8.3M 2.0G 1% /runtmpfs 2.0G 0 2.0G 0% /sys/fs/cgroup 这里的-h标记是为了告诉dh将信息输出为对人类友好的格式，比如以MB或GB为单位输出空间使用和空余情况，而不是直接输出内存块的个数。 从第一行可以看到我们的存储分区上还有59GB的空间剩余，这足够我们操作了。（我这是一台中等规模的新建云主机，每个人的情况可能有很大不同。） 合适的swap空间是多大？关于这个问题有很多种选择，这取决于你的应用需求和你个人的偏好。一般来说，内存容量的两倍就是个不错的起点。 我的系统内存有4GB，如果设置8GB的swap会占据太多空间，所以我决定只设置4GB就好。 创建Swap文件接下来我们将在文件系统上创建swap文件。我们要在根目录（/）下创建一个名叫swapfile的文件，当然你也可以选择你喜欢的文件名。该文件分配的空间将等于我们需要的swap空间。 最快捷的创建方式是fallocate命令，该命令能够创建一个预分配指定大小空间的文件。输入如下指令创建一个4GB的文件： 1sudo fallocate -l 4G /swapfile 输入密码后，该swap文件将立即创建完毕。我们可以用ls命令检查文件大小： 123ls -lh /swapfile-rw-r--r-- 1 root root 4.0G Oct 30 11:00 /swapfile 至此，我们的swap文件就创建完毕了。 启用Swap文件现在我们已经有了swap文件，但系统还不知道应该使用该文件作为swap，这就需要我们告知系统将该文件格式化为swap并启用起来。 首先我们需要更改swap文件的权限，确保只有root才可读，否则会有很大的安全隐患。使用chmod命令进行权限操作： 1sudo chmod 600 /swapfile 如此，该文件的读写都只有root才能操作。使用ls -lh命令检查一下： 123ls -lh /swapfile-rw------- 1 root root 4.0G Oct 30 11:00 /swapfile 然后，使用如下命令告知系统将该文件用于swap： 1234sudo mkswap /swapfileSetting up swapspace version 1, size = 4194300 KiBno label, UUID=b99230bb-21af-47bc-8c37-de41129c39bf 现在，这个swap文件就可以作为swap空间使用了。输入如下命令开始使用该swap： 1sudo swapon /swapfile 我们可以输入如下命令来确认一下设置是否已经生效： 1234swapon -sFilename Type Size Used Priority/swapfile file 4194300 0 -1 可以看到返回的结果中已经有我们刚才设置的swap。再使用free工具确认一下： 123456free -m total used free shared buffers cachedMem: 3953 315 3637 8 11 107-/+ buffers/cache: 196 3756Swap: 4095 0 4095 至此，我们的swap已经设置完毕，操作系统会在需要的时候使用它。 使Swap文件永久生效至此我们已经在系统中启用了swap文件，然而一旦系统重启后，服务器还不能自动启用该文件。要让系统在重启后自动生效swap，我们可以通过修改fstab文件来实现（这是一个管理文件系统和分区的表）。 用sudo权限打开该文件编辑： 1sudo nano /etc/fstab 在文件末尾加入下面这行内容，告诉操作系统自动使用刚才创建的swap文件： 1/swapfile swap swap sw 0 0 添加完毕后，保存退出。以后服务器每次重启都会检查该文件并自动启用swap。 更改Swap配置（可选）有几个涉及swap的选项可能会影响到系统的性能表现。大部分情况下这些选项是可选的，具体要修改成什么样则取决于你的应用需求以及个人偏好。 Swappinessswappiness参数决定了系统将数据从内存交换到swap空间的频率，数值设置在0到100之间，代表系统将数据从内存交换到swap空间的力度。 该数值越接近于0，系统越倾向于不进行swap，仅在必要的时候进行swap操作。由于swap要比内存慢很多，因此减少对swap的依赖意味着更高的系统性能。 该数值越接近于100，系统越倾向于多进行swap。有些应用的内存使用习惯更适合于这种情况，这也于服务器的用途有关。 输入如下命令查看当前的swappiness数值： 123cat /proc/sys/vm/swappiness30 CentOS 7默认设置了30的swappiness，这对于大部分桌面系统和本地服务器是比较中庸的数值。对于VPS系统而言，可能接近于0的值是更加合适的。 使用sysctl命令可以修改swappiness。比如将swappiness设为10： 123sudo sysctl vm.swappiness=10vm.swappiness = 10 本次修改将一直生效到下次重启前。如果希望永久修改该数值，则需要编辑sysctl配置文件： 1sudo nano /etc/sysctl.conf 将以下内容粘贴到文件末尾： 1vm.swappiness = 10 编辑完成后，保存退出，之后服务器每次重启的时候会将swappiness设置为该值。 缓存压力（Cache Pressure ）另一个可以考虑更改的配置项是vfs_cache_pressure，该配置项涉及特殊文件系统元文件条目的存储。对此类信息的频繁读取是非常消耗性能的，所以延长其在缓存的保存时间可以提升系统的性能。 通过proc文件系统查看缓存压力的当前设定值： 123cat /proc/sys/vm/vfs_cache_pressure100 这个数值是比较高的，意味着系统从缓存中移除inode信息的速度比较快。一个保守一些的数值是50，使用sysctl命令进行设置： 123sudo sysctl vm.vfs_cache_pressure=50vm.vfs_cache_pressure = 50 这条命令仅在重启前有效。要让该设置永久有效，需要编辑sysctl配置文件： 1sudo nano /etc/sysctl.conf 在文件末尾添加如下内容： 1vm.vfs_cache_pressure = 50 保存退出，服务器就会在每次重启后都自动将缓存压力设置为50了。 总结至此，我们的系统内存就获得了一些喘气的空间。有了swap空间可以有效避免一些常见的问题。 如果你仍然会遇到内存不足（OOM，out of memory）的错误信息，或者你的系统不能运行你需要的应用，那么最好的方法是优化你的应用配置或者升级你的服务器，不过配置swap空间也不失为一个灵活的节省方案。 本文来源自DigitalOcean Community。英文原文：How To Add Swap on CentOS 7 by Josh Barnett","categories":[{"name":"运维","slug":"运维","permalink":"https://copy.moe/categories/运维/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://copy.moe/tags/centos/"},{"name":"swap","slug":"swap","permalink":"https://copy.moe/tags/swap/"}]},{"title":"NodeBB数据库备份与恢复","slug":"nodebb-database-backup-restore","date":"2018-10-14T03:30:12.000Z","updated":"2019-04-08T15:55:23.784Z","comments":true,"path":"2018/10/14/nodebb-database-backup-restore/","link":"","permalink":"https://copy.moe/2018/10/14/nodebb-database-backup-restore/","excerpt":"","text":"NodeBB在MongoDB下的备份和恢复操作。 数据库备份1$ mongodump -u nodebb -p yourpassword --authenticationDatabase=nodebb -d nodebb 命令解释： -u：用户名，如果按照官方教程来做，则用户名为nodebb -p：密码 –authenticationDatabase：等待进行验证的数据库，一般写你的数据库名 -d：你的数据库名，如果按照官方教程来做，则数据库名为nodebb 以上命令会在当前目录下生成dump目录，在里面有一个叫nodebb的目录，其内即为数据文件。 数据库恢复1$ mongorestore -u nodebb -p yourpassword --authenticationDatabase=nodebb -d nodebb --drop dump/nodebb 命令解释： -u：用户名，如果按照官方教程来做，则用户名为nodebb -p：密码 –authenticationDatabase：等待进行验证的数据库，一般写你的数据库名 -d：你的数据库名，如果按照官方教程来做，则数据库名为nodebb –drop dump/nodebb：如果不加--drop这个参数，那么数据库内原有的数据不会被清除，导入时会遇到数据重复！会出现大量警告提示。加了这个参数就是先清掉数据库原有的内容，再将备份导入。后面的dump/nodebb是你当时导出数据的目录，这里用的相对路径 自动备份手动备份很麻烦，很不智能，还容易出错，作为一个Geek是不允许这种事情发生的。于是有了下面的自动备份脚本，该脚本将在每天凌晨3点30分自动对数据库进行备份，然后对备份后的数据文件进行压缩打包，之后删除三天前的历史备份档案，只保留最近三天的备份。你最终看到的就是备份目录内只有最近三天的备份文件压缩包。 123456backup_date=$(date +\"%F\") #获取日期cd /root/ #切换到当前用户家目录，你可以换成你的用户目录/usr/bin/mongodump -u nodebb -p yourpassword --authenticationDatabase=nodebb -d nodebb #导出数据库备份tar -zcvf dump/$&#123;backup_date&#125;.tar.gz dump/nodebb --remove-files #将导出的备份压缩打包，并以日期命名压缩包find dump/ -mtime +3 | xargs rm -f #检索三天前的备份压缩包，将之删除echo $(date +\"%F %H:%M:%S\") Backup successfully ! &gt;&gt; log.backup #写入日志 将上述脚本保存到/root/script/目录下，并命名为backup.sh 使用命令chmod u+x /root/script/backup.sh为脚本添加可执行权限 运行命令crontab -e打开crontab的任务添加界面，加入下面这一行： 130 3 * * * /root/script/backup.sh 使用crontab -l就可以看到刚才添加的定时任务了。","categories":[],"tags":[{"name":"nodebb","slug":"nodebb","permalink":"https://copy.moe/tags/nodebb/"},{"name":"mongodb","slug":"mongodb","permalink":"https://copy.moe/tags/mongodb/"}]},{"title":"JavaScript使用函数实现Hangman","slug":"javascript-function-hangman","date":"2018-09-22T09:37:08.000Z","updated":"2019-07-11T09:28:31.883Z","comments":true,"path":"2018/09/22/javascript-function-hangman/","link":"","permalink":"https://copy.moe/2018/09/22/javascript-function-hangman/","excerpt":"JavaScript使用函数实现Hangman","text":"JavaScript使用函数实现Hangman 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 var pickWord = function () &#123; var words = [ \"javascript\", \"monkey\", \"amazing\", \"pancake\" ]; return words[Math.floor(Math.random() * words.length)]; &#125;; var setupAnswerArray = function (word) &#123; var answerArray = []; for (var i = 0; i &lt; word.length; i++) &#123; answerArray[i] = \"_\"; &#125; return answerArray; &#125;; var showPlayerProgress = function (answerArray) &#123; alert(answerArray.join(\" \")); &#125;; var getGuess = function () &#123; return prompt(\"Guess a letter, or click Cancel to stop playing.\"); &#125;; var updateGameState = function (guess, word, answerArray) &#123; var appearances = 0; for (var j = 0; j &lt; word.length; j++) &#123; if (word[j] === guess) &#123; answerArray[j] = guess; appearances++; &#125; &#125; return appearances; &#125;; var showAnswerAndCongratulatePlayer = function (answerArray) &#123; showPlayerProgress(answerArray); alert(\"Good job! The answer was \" + answerArray.join(\"\")); &#125;; var word = pickWord(); var answerArray = setupAnswerArray(word); var remainingLetters = word.length; while (remainingLetters &gt; 0) &#123; showPlayerProgress(answerArray); var guess = getGuess(); if (guess === null) &#123; break; &#125; else if (guess.length !== 1) &#123; alert(\"Please enter a single letter.\"); &#125; else &#123; var correctGuesses = updateGameState(guess, word, answerArray); remainingLetters -= correctGuesses; &#125; &#125;showAnswerAndCongratulatePlayer(answerArray);","categories":[{"name":"代码","slug":"代码","permalink":"https://copy.moe/categories/代码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://copy.moe/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-15T10:00:00.000Z","updated":"2019-04-08T15:55:39.353Z","comments":true,"path":"2018/09/15/hello-world/","link":"","permalink":"https://copy.moe/2018/09/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}